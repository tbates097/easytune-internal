import "Multisine.a1lib" as static

//Frequency Response Settings
var $motionAxes[] as axis = [X,Y] //axes to move around full travel
var $disturbanceAxes[] as axis = [X,Y,Z] //axes inject multisine disturbance
var $collectionAxes[] as axis = [X,Y,Z] //axes to collect data
var $numLocations[length($motionAxes)] as integer = [3,3] //number of locations across entire travel for each motion axis
var $amplitudes[length($disturbanceAxes)] as real = [5.0,5.0,5.0] //% max current for the RMS of the excitation
var $startFreq as real = 10.0 //Hz
var $endFreq as real = 2000.0 //Hz
var $pointDensity as Multisine_PointDensity = Multisine_PointDensity.Fine //determines the frequency spacing of the response
var $numAvgs as integer = 4 //number of each disturbance array to collect to average the data
var $outputFolder as string = "/MIMOSystemID/4Avg/" //folder to save all dat and log files to
var $filenamePrefix as string = "FRD" //prefix to put at the beginning of the dat filenames

//Other variables
var $startLocation[length($motionAxes)] as real
var $locationDelta[length($motionAxes)] as real
var $thisLocation[length($motionAxes)] as real
var $locationCounters[length($motionAxes)] as integer
var $numDataCollections, $thisDistNumPoints, $thisNumCollectionPoints as integer
var $distAxisIndex, $distIndex, $index, $totalLocations, $totalLocationCounter  as integer
var $temp, $moveSpeed, $servoRate, $sampleTime, $transientTime as real
var $filename, $axisLocString, $tempString as string
var $fileLog as handle
var $thisMultisineInfo as MultisineInfo

program

	ParameterSetTaskValue(TaskGetIndex(),TaskParameter.ExecuteNumLines, 200)
	
	//Get the servo rate of the axis that is going to be excited which is also the data collection rate
	$servoRate = StatusGetAxisItem($disturbanceAxes[0], AxisDataSignal.ServoUpdateRate)*1000.0
	$sampleTime = 1000.0/$servoRate //store the sample time in msec for the data collection rate
	
	//Use the home speed to move the axes around
	$moveSpeed = ParameterGetAxisValue($motionAxes[0],AxisParameter.HomeSpeed)
	
	//Loop over all of the motion axes to determine the positions and if everything is setup properly
	for $index = 0 to length($motionAxes)-1
		
		//Check if the software limits have been setup, error if any are not
		if ParameterGetAxisValue($motionAxes[$index], AxisParameter.SoftwareLimitHigh) == ParameterGetAxisValue($motionAxes[$index], AxisParameter.SoftwareLimitLow)
			AppMessageBox("No Software Limits!","Software limits need to be configured on "+AxisToString($motionAxes[$index])+"!",["Ok"],MessageSeverity.Error,1)
			ProgramExit()
		end
		
		//Check all of the disturbance axes have the same servo rate, error if they are not
		if StatusGetAxisItem($disturbanceAxes[$index], AxisDataSignal.ServoUpdateRate)*1000.0 != $servoRate
			AppMessageBox("Error", "All axes must have the same servo rate!",["Ok"],MessageSeverity.Error, 1)
			ProgramExit()
		end
		
		//Update the move speed to be the smallest of all axes
		if ParameterGetAxisValue($motionAxes[$index],AxisParameter.HomeSpeed) < $moveSpeed
			$moveSpeed = ParameterGetAxisValue($motionAxes[$index],AxisParameter.HomeSpeed)
		end
		
		//Calculate the start location of each axis and move delta between locations
		if ParameterGetAxisValue($motionAxes[$index], AxisParameter.ReverseMotionDirection) == 1
			$startLocation[$index] = ParameterGetAxisValue($motionAxes[$index], AxisParameter.SoftwareLimitHigh)*-1
			$temp = ParameterGetAxisValue($motionAxes[$index], AxisParameter.SoftwareLimitLow)*-1
			if $startLocation[$index] > 0
				$startLocation[$index] -= 0.1
			elseif $startLocation[$index] < 0
				$startLocation[$index] += 0.1
			end
			if $temp > 0
				$temp -= 0.1
			elseif $temp < 0
				$temp += 0.1
			end
		else
			$startLocation[$index] = ParameterGetAxisValue($motionAxes[$index], AxisParameter.SoftwareLimitLow)
			$temp = ParameterGetAxisValue($motionAxes[$index], AxisParameter.SoftwareLimitHigh)
			if $startLocation[$index] > 0
				$startLocation[$index] -= 0.1
			elseif $startLocation[$index] < 0
				$startLocation[$index] += 0.1
			end
			if $temp > 0
				$temp -= 0.1
			elseif $temp < 0
				$temp += 0.1
			end
		end
		
		if $numLocations[$index] <= 1
			//If there is only one location for this axis, center the axis
			$numLocations[$index] = 1
			$locationDelta[$index] = 0
			$startLocation[$index] = ($temp - $startLocation[$index]) / 2.0
		else
			$locationDelta[$index] = ($temp - $startLocation[$index]) / ($numLocations[$index]-1)
		end
		$locationCounters[$index]=0
	end
	
	//Prompt to continue with enabling and motion
	if AppMessageBox("Continue?", "System is about to be enabled and moved.\nPlease verify there are no crash conditions.\n\nContinue?",["Yes","No"],MessageSeverity.Warning,1) != 0
		//User clicked no or closed window.
		ProgramExit()
	end
	
	//Enable and home if needed
	Enable($motionAxes)
	Enable($disturbanceAxes)
	Enable($collectionAxes)
	HomeConditional($motionAxes)
	
	//Log out information about this run so that it can be duplicated
	LogSettings()
	
	//Calculate the total number of locations
	$totalLocations = $numLocations[0]
	for $index = 1 to length($motionAxes)-1
		$totalLocations *= $numLocations[$index]
	end

	//Stop any data collection
	DataCollectionStop()
	
	//Setup the multisine disturbance in the library
	//Get the number of disturbances and initialize the internal values of the library
	$numDataCollections = Multisine_Initialize($startFreq,$endFreq,$pointDensity,$servoRate)
	
	//Export the information about the disturbance arrays
	Multisine_ExportInfo($outputFolder+"Multisine_Info.csv")
	
	//Create a file to log all of the information about each disturbance and collected dat file
	$fileLog = FileOpenText($outputFolder+$filenamePrefix+"_FileLog.csv", FileMode.Overwrite)
	
	//Setup error catching to close out files
	onerror(closeFiles())
	
	//Write header to log file
	$tempString = "filename,startFreq,endFreq,freqSpacing,numPts,numPeriods,numCollectedPts,sampleRate,disturbanceAxisInd,disturbanceAxisName"
	foreach var $thisAx in $motionAxes
		$tempString += ","+AxisToString($thisAx)+"LocInd,"+AxisToString($thisAx)+"Position"
	end
	FileTextWriteString($fileLog, $tempString+"\n")
	
	//Loop over all of the locations
	for $totalLocationCounter = 0 to $totalLocations-1
		
		//Move all axes to the correct location
		$axisLocString=""
		for $index = 0 to length($motionAxes)-1
			$thisLocation[$index] = $startLocation[$index] + $locationDelta[$index] * $locationCounters[$index]
			$axisLocString+= AxisToString($motionAxes[$index])+IntegerToString($locationCounters[$index])
		end
		
		SetupTaskTargetMode(TargetMode.Absolute)
		SetupTaskWaitMode(WaitMode.MotionDone)
		MoveLinear($motionAxes,$thisLocation,$moveSpeed)
		Dwell(1.0)
		
		//Loop over all axes to inject disturbance
		for $distAxisIndex = 0 to length($disturbanceAxes)-1
	
			//Configure the data items to collect
			DataCollectionReset()
			
			//Gather the standard open loop response item to be able to back calculate the time aligned disturbance
			DataCollectionAddAxisSignal($disturbanceAxes[$distAxisIndex],AxisDataSignal.FrequencyResponseBefore)
			
			//Gather the current command and position feedback of all of the specified collection axes
			foreach var $myAxis in $collectionAxes
				if $servoRate > 20000
					DataCollectionAddAxisSignal($myAxis,AxisDataSignal.CurrentCommand)
				else
					DataCollectionAddAxisSignal($myAxis,AxisDataSignal.ControlEffort)
				end
				DataCollectionAddAxisSignal($myAxis,AxisDataSignal.PositionFeedback)
			end
		
			//Loop over each disturbance and collect data
			for $distIndex = 0 to $numDataCollections-1
			
				//Send disturbance to the drive
				$thisDistNumPoints = Multisine_SendDisturbance($disturbanceAxes[$distAxisIndex],$distIndex)
				$thisNumCollectionPoints = $thisDistNumPoints*$numAvgs
				
				//Also grab all of the other info of this disturbance from the library
				Multisine_GetMultisineInfo($thisMultisineInfo)
				
				//Set filename for data collection
				$filename = $outputFolder+$filenamePrefix+"_"+$axisLocString+"_"+AxisToString($disturbanceAxes[$distAxisIndex])+"Dist_"+IntegerToString($distIndex+1)+".dat"
				
				//Log out information about this file
				$tempString = $filename+","+RealToString($thisMultisineInfo.startFreq)+","+RealToString($thisMultisineInfo.endFreq)+","+RealToString($thisMultisineInfo.freqSpacing)+","+IntegerToString($thisMultisineInfo.numPoints)+","+IntegerToString($thisMultisineInfo.numPeriods)+","+IntegerToString($thisNumCollectionPoints)+","+RealToString($thisMultisineInfo.servoRate)+","+IntegerToString($distAxisIndex)+","+AxisToString($disturbanceAxes[$distAxisIndex])
				for $temp = 0 to length($motionAxes)-1
					$tempString += ","+IntegerToString($locationCounters[$temp])+","+RealToString($thisLocation[$temp])
				end
				FileTextWriteString($fileLog, $tempString+"\n")
				
				//Calculate time to wait between starting the excitation and starting data collection
				//This is done by waiting for 5 periods of the lowest frequency in each disturbance rounded up to the next msec
				//This is calculated as follows:
				$transientTime = Ceil($thisDistNumPoints / $pointDensity * 5.0 / $servoRate * 1000.0) / 1000.0
				if $transientTime < 0.001
					$transientTime = 0.001
				end
				
				//Start disturbance
				if $amplitudes[$distAxisIndex]*$thisMultisineAmplitudeScale > 100.0
					TuningDisturbanceMeasurementOn($disturbanceAxes[$distAxisIndex], TuningDisturbanceType.DriveArray, TuningMeasurementType.ServoOpenLoop, 100, 0)
				else
					TuningDisturbanceMeasurementOn($disturbanceAxes[$distAxisIndex], TuningDisturbanceType.DriveArray, TuningMeasurementType.ServoOpenLoop, $amplitudes[$distAxisIndex]*$thisMultisineAmplitudeScale, 0)
				end
				
				TimerClear(0)
			
				//Wait for any previous data retrieval to be done
				while (StatusGetSystemItem(SystemStatusItem.DataCollectionStatus) & DataCollectionFlags.UploadingDriveBuffers)
					Dwell(0.001)
				end
				
				//Data collection needs to be stopped if it had been triggered previously
				if $distIndex > 0
					DataCollectionStop()
				else
					//Wait longer for things to settle in if this is the first disturbance at a location
					Dwell(1.0)
				end
				
				//Make sure transient time has ellapsed before starting the data collection
				while TimerRead(0, TimerMode.Standard) <= $transientTime
					Dwell(0.001)
				end
				
				//Trigger the data collection
				DataCollectionStart($filename, $thisNumCollectionPoints, $sampleTime)
				
				//Wait for the data collection to be done
				while (StatusGetSystemItem(SystemStatusItem.DataCollectionStatus) & DataCollectionFlags.Triggered)
					Dwell(0.001)
				end
				
				//Turn off the distubance
				TuningDisturbanceMeasurementOff($disturbanceAxes[$distAxisIndex])
				
			end
			
			//Wait for the data retrieval to be done
			while (StatusGetSystemItem(SystemStatusItem.DataCollectionStatus) & DataCollectionFlags.UploadingDriveBuffers)
				Dwell(0.001)
			end
			
			//Finalize last dat file for this frequency response
			DataCollectionStop()
		end

		//Increment index values for each motion axis
		$locationCounters[0]++
		for $index = 0 to length($locationCounters)-2
			//Roll over location index to next axis if needed
			if $locationCounters[$index] > $numLocations[$index]-1
				$locationCounters[$index] = 0
				$locationCounters[$index+1]++
			end
		end
	end
	
	// Disable the active onerror handler
	onerror()
	
	FileClose($fileLog)
	AppMessageBox("Completed","Done!",["Ok"],MessageSeverity.Information,1)
end

function HomeConditional($axes[] as axis)
	foreach var $axis in $axes
		if StatusGetAxisItem($axis, AxisStatusItem.AxisStatus, AxisStatus.Homed) != AxisStatus.Homed
			HomeAsync($axis)
		end
	end
	WaitForMotionDone($axes)
end

function LogSettings()
	$fileLog = FileOpenText($outputFolder+"ProgramSettings.ini",FileMode.Overwrite)
	FileTextWriteString($fileLog,"[Settings]\n")
	
	$tempString = "motionAxes = "+AxisToString($motionAxes[0])
	for $index = 1 to length($motionAxes)-1
		$tempString += ","+AxisToString($motionAxes[$index])
	end
	FileTextWriteString($fileLog,$tempString+"\n")
	
	$tempString = "disturbanceAxes = "+AxisToString($disturbanceAxes[0])
	for $index = 1 to length($disturbanceAxes)-1
		$tempString += ","+AxisToString($disturbanceAxes[$index])
	end
	FileTextWriteString($fileLog,$tempString+"\n")
	
	$tempString = "collectionAxes = "+AxisToString($collectionAxes[0])
	for $index = 1 to length($collectionAxes)-1
		$tempString += ","+AxisToString($collectionAxes[$index])
	end
	FileTextWriteString($fileLog,$tempString+"\n")
	
	$tempString = "numLocations = "+IntegerToString($numLocations[0])
	for $index = 1 to length($numLocations)-1
		$tempString += ","+IntegerToString($numLocations[$index])
	end
	FileTextWriteString($fileLog,$tempString+"\n")
	
	$tempString = "amplitudes = "+RealToString($amplitudes[0])
	for $index = 1 to length($amplitudes)-1
		$tempString += ","+RealToString($amplitudes[$index])
	end
	FileTextWriteString($fileLog,$tempString+"\n")
	
	FileTextWriteString($fileLog,"startFreq = "+RealToString($startFreq)+"\n")
	FileTextWriteString($fileLog,"endFreq = "+RealToString($endFreq)+"\n")
	FileTextWriteString($fileLog,"pointDensity = "+IntegerToString($pointDensity)+"\n")
	FileTextWriteString($fileLog,"numAvgs = "+IntegerToString($numAvgs)+"\n")
	FileTextWriteString($fileLog,"outputFolder = "+$outputFolder+"\n")
	FileTextWriteString($fileLog,"filenamePrefix = "+$filenamePrefix+"\n")
	
	FileClose($fileLog)
end

function closeFiles()
	FileClose($fileLog)
	DataCollectionStop()
end